@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f crackers_selectholpl_ops

@c
/*
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold, Eleni Petraki
 * @d March 2006 - July 2007
 * @* Select Operators
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(sht,simple,,sht)@
@:@1(int,simple,,int)@
@:@1(lng,simple,,lng)@
@:@1(flt,simple,,flt)@
@:@1(dbl,simple,,dbl)@
@:@1(date,atom,TYPE_,loc)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_SELECTHOLPL_H_
#define _CRACKERS_SELECTHOLPL_H_

#define dt(a,b) (b.tv_sec - a.tv_sec + (b.tv_usec - a.tv_usec) * 1e-6)

/* Exported signatures */
@:TypeSwitch(SelectholplFunctions_decl)@

#endif /* _CRACKERS_SELECTHOLPL_H */
/*
 * @- Exported signatures
 */
@= SelectholplFunctions_decl
crackers_export str CRKselectholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKuselectholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKselectholplValue_@1(int *vid, int *bid, @1 *value);
crackers_export str CRKuselectholplValue_@1(int *vid, int *bid, @1 *value);
crackers_export str CRKselectholpl_@1(int *vid, int *bid, @1 *low, @1 *hgh);
crackers_export str CRKuselectholpl_@1(int *vid, int *bid, @1 *low, @1 *hgh);
crackers_export str CRKthetaselectholpl_@1(int *vid, int *bid, @1 *val, str *op);
crackers_export str CRKthetauselectholpl_@1(int *vid, int *bid, @1 *val, str *op);
crackers_export str CRKsumholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export int CRKrandomholpl_@1(int *bid, bit *inclusiveHgh);
/*new multi-threaded versions*/
crackers_export str CRKselectholplBounds_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, const int *nthreads, const int *vector_elements);
crackers_export str CRKuselectholplBounds_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, const int *nthreads, const int *vector_elements);
crackers_export str CRKselectholplValue_@1_MT(int *vid, int *bid, @1 *value, const int *nthreads, const int *vector_elements);
crackers_export str CRKuselectholplValue_@1_MT(int *vid, int *bid, @1 *value, const int *nthreads, const int *vector_elements);
crackers_export str CRKselectholpl_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, const int *nthreads, const int *vector_elements);
crackers_export str CRKuselectholpl_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, const int *nthreads, const int *vector_elements);
crackers_export str CRKthetaselectholpl_@1_MT(int *vid, int *bid, @1 *val, str *op, const int *nthreads, const int *vector_elements);
crackers_export str CRKthetauselectholpl_@1_MT(int *vid, int *bid, @1 *val, str *op, const int *nthreads, const int *vector_elements);
crackers_export str CRKsumholplBounds_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, const int *nthreads, const int *vector_elements);
crackers_export int CRKrandomholpl_@1_MT(int *bid, bit *inclusiveHgh, int nthreads, int vector_elements);
@

@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"
//#include <papi.h>

/* Local support functions and macros */
@:TypeSwitch(crackOperations)@

/* Exported functions */
@:TypeSwitch(SelectholplFunctions_impl)@
/*
 * @- Exported functions
 */
@= SelectholplFunctions_impl

str
CRKselectholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	return CRKselectholplBounds_@1_MT(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, &int_nil, &int_nil);
}
str
CRKselectholplBounds_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, const int *nthreads, const int *vector_elements){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, TRUE, *nthreads, *vector_elements);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, TRUE, *nthreads, *vector_elements);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, TRUE, *nthreads, *vector_elements);
}
str
CRKuselectholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	return CRKuselectholplBounds_@1_MT(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, &int_nil, &int_nil);
}
str
CRKuselectholplBounds_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, const int *nthreads, const int *vector_elements){
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeLeftNilTree_@1(vid, bid, hgh, inclusiveHgh, FALSE, *nthreads, *vector_elements);
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		return CRKRangeRightNilTree_@1(vid, bid, low, inclusiveLow, FALSE, *nthreads, *vector_elements);
	else
		return CRKRangeTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE, *nthreads, *vector_elements);
}
str
CRKselectholplValue_@1(int *vid, int *bid, @1 *value){
	return CRKselectholplValue_@1_MT(vid, bid, value, &int_nil, &int_nil);
}
str
CRKselectholplValue_@1_MT(int *vid, int *bid, @1 *value, const int *nthreads, const int *vector_elements){
	bit inclusive = TRUE;
	return CRKuselectholplBounds_@1_MT(vid, bid, value, value, &inclusive, &inclusive, nthreads, vector_elements);
}
str
CRKuselectholplValue_@1(int *vid, int *bid, @1 *value){
	return CRKuselectholplValue_@1_MT(vid, bid, value, &int_nil, &int_nil);
}
str
CRKuselectholplValue_@1_MT(int *vid, int *bid, @1 *value, const int *nthreads, const int *vector_elements){
	bit inclusive = TRUE;
	return CRKuselectholplBounds_@1_MT(vid, bid, value, value, &inclusive, &inclusive, nthreads, vector_elements);
}
str
CRKselectholpl_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	return CRKselectholpl_@1_MT(vid, bid, low, hgh, &int_nil, &int_nil);
}
str
CRKselectholpl_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, const int *nthreads, const int *vector_elements){
	bit inclusive = TRUE;
	return CRKselectholplBounds_@1_MT(vid, bid, low, hgh, &inclusive, &inclusive, nthreads, vector_elements);
}
str
CRKuselectholpl_@1(int *vid, int *bid, @1 *low, @1 *hgh){
	return CRKuselectholpl_@1_MT(vid, bid, low, hgh, &int_nil, &int_nil);
}
str
CRKuselectholpl_@1_MT(int *vid, int *bid, @1 *low, @1 *hgh, const int *nthreads, const int *vector_elements){
	bit inclusive = TRUE;
	return CRKuselectholplBounds_@1_MT(vid, bid, low, hgh, &inclusive, &inclusive, nthreads, vector_elements);
}
str
CRKthetaselectholpl_@1(int *vid, int *bid, @1 *val, str *OP){
	return CRKthetaselectholpl_@1_MT(vid, bid, val, OP, &int_nil, &int_nil);
}
str
CRKthetaselectholpl_@1_MT(int *vid, int *bid, @1 *val, str *OP, const int *nthreads, const int *vector_elements){
	ptr nilptr = ATOMnilptr(TYPE_@1); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@1 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
		high = NULL;
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetaselectholpl", "unknown operator");
	}

	return CRKselectholplBounds_@1_MT(vid, bid, low, high, &lin, &rin, nthreads, vector_elements);
}
str
CRKthetauselectholpl_@1(int *vid, int *bid, @1 *val, str *OP){
	return CRKthetauselectholpl_@1_MT(vid, bid, val, OP, &int_nil, &int_nil);
}
str
CRKthetauselectholpl_@1_MT(int *vid, int *bid, @1 *val, str *OP, const int *nthreads, const int *vector_elements){
	ptr nilptr = ATOMnilptr(TYPE_@1); 
	char *op = *OP; 
	bit lin = TRUE, rin = TRUE;
	@1 *low = nilptr, *high = nilptr;

	if (op[0] == '=') {
		low = val; 
	} else if (op[0] == '<') {
		high = val;
		rin = (op[1] == '=');
	} else if (op[0] == '>') {
		low = val;
		lin = (op[1] == '=');
	} else {
		throw(MAL, "crackers.thetauselectholpl", "unknown operator");
	}

	return CRKuselectholplBounds_@1_MT(vid, bid, low, high, &lin, &rin, nthreads, vector_elements);
}
str
CRKsumholplBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	return CRKRangeSumTree_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, FALSE);
}
int
CRKrandomholpl_@1(int *bid, bit *inclusiveHgh)
{
	return CRKrandomholpl_@1_MT(bid, inclusiveHgh, int_nil, int_nil);
}
int
CRKrandomholpl_@1_MT(int *bid, bit *inclusiveHgh, int nthreads, int vector_elements){

	BAT *b,*c;
	int  m;
	int *t;
	oid p;
	int gapH = 1;
        //int retryIterations=0;
	@1 *hgh=NULL;
	pthread_rwlock_t *plock=0;
	oid vh=0;
	oid cl2=0, ch2=0;
	bit foundHgh=0;
	bit HBound=FALSE;
	struct Node *lowNode=NULL;
	BUN idxFirst;
	int incr_pieces=0;
	struct timeval tv0, tv1;
	double wt=0, ct=0;
	int countBatElements=0;
	int L1=0; /*Number of elements that can fit into L1 cache (size: 32KB)*/	
	int mod_bid=0;
	FILE *ofp;
	char *outputFilename1;
	FrequencyNode* FN;
	FrequencyNode *FrequencyStructA = getFrequencyStruct('A');

	gettimeofday(&tv0,0);

	hgh=(@1*) GDKmalloc(sizeof(@1));
        if (hgh==NULL)
                return -1;

	outputFilename1 = getenv("HOLOUTPUT_PIECES");
	if (outputFilename1 == NULL){
  		fprintf(stderr, "Error: HOLOUTPUT_PIECES\n");
  		exit(1);
	}

	L1=32000/ATOMsize(TYPE_@1);

	ofp = fopen(outputFilename1,"a");
	if (ofp == NULL) {
  		fprintf(stderr, "Can't open output file!\n");
  		exit(1);
	}

	mod_bid=ABS(*bid)%LOCKS;

	MT_lock_set(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_set(&CRKIndexLock,"Cracker Index Lock");

	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;

	m = existsCrackerIndex(*bid);
	/* if this is the first time we selectholpl something from this bat,
		we have to create the crack index for it and
	   if necessary materialize the head of the bat */
	if (m == -1)
		return -1;
		
	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		return -1;

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		return -1;

	idxFirst = BUNfirst(c);

	MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");

	countBatElements=BATcount(b);

	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	
	retry:;

	t = (int *) Tloc(b, BUNfirst(b));
	p=rand()%countBatElements;
	*hgh=t[p];

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);

	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;

	/* If one or both of the result view bounds were not found using the
	index then we have to crack */

        if (foundHgh == 0){
                 pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
                 gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
                 lowNode = findNodeL_@1(*hgh, TRUE, CrackerIndex[m].Tree, c, idxFirst, NULL);
                 plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
                 if (pthread_rwlock_trywrlock(plock)){
                         pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                         gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
                         pthread_rwlock_wrlock(plock);
                         gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
                         pthread_rwlock_unlock(plock);
                        //retryIterations++;
                        //if (retryIterations > 5)
                        //      return -1;
                         goto retry;     // some other thread might already crack on low, try to find it again
                 }
                 pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                 @:crkTwoRTree(@1)@
                 gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
                 pthread_rwlock_wrlock(&CrackerIndex[m].columnRWLock);
                 gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
                 if (IndexSize <IndexStop)
                 {
                         if(gapH>0)
                         {
                                 addCrackerIndex_@1(m,hgh,HBound,vh,c);
                                 incr_pieces++;
                         }
                 }
                 pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                 pthread_rwlock_unlock(plock);
        }
        else
                 vh = ch2;

	countBatElements=BATcount(b);
	MT_lock_set(&frequencylock, "getFrequencyStruct");
	FN=searchBAT(FrequencyStructA,*bid);
	FN->c = FN->c + incr_pieces;
	if(FN->weight > 0)
		FN->weight = changeWeight(FN,countBatElements,L1);
	fprintf(ofp,"Idle_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\n",FN->bid,FN->c,wt,ct,MT_getpid());
	fclose(ofp);
	MT_lock_unset(&frequencylock, "getFrequencyStruct");

	return 0;
}


@

 * @- Local support functions and macros

@= crkThreeTree
        /*printf("crack in three pieces\n");*/
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree@4_LE_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree@4_LE_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree@4_LO_RE_@1(b,*low,*hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree@4_LO_RO_@1(b,*low,*hgh, @2, @3, &vl, &vh);
				
	/*if (vl != -1 && vh != -1){*/
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,hgh,HBound,vh,c);
	
@
@= crkThreeTreeCopy
        /*printf("crack in three pieces\n");*/
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeCopy_LE_RE_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeCopy_LE_RO_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeCopy_LO_RE_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeCopy_LO_RO_@1(bo,*low,*hgh, @2, @3, &vl, &vh,b);

        /*if (vl != -1 && vh != -1){*/
                if (vl>0) _vl=vl-1; else _vl=vl;
                addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
                addCrackerIndex_@1(m,hgh,HBound,vh,c);

@

@= crkTwoLTree
	/*CRACK in two pieces cl1-ch1 using >incLow bound*/
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero@2_RE_@1(b,*low, cl1, ch1,&vl, nthreads, vector_elements);
	else
		CRKcrackUnorderedZero@2_LE_@1(b,*low, cl1, ch1,&vl, nthreads, vector_elements);
	
	if (vl < cl1){
		/*then the left piece is empty*/
		gapL = -1;
	}
	if (vl > ch1){
		/*then the right piece is empty*/
		/*vl--;*/
		gapL = -1;
	}


	vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
		Instead we want the first bun of the right piece*/
@
@= crkTwoRTree
	/*CRACK in two pieces cl2-ch2 using <incHgh bound*/
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero@2_LE_@1(b,*hgh, cl2, ch2,&vh, nthreads, vector_elements);
	else
		CRKcrackUnorderedZero@2_RE_@1(b,*hgh, cl2, ch2,&vh, nthreads, vector_elements);

	if (vh < cl2)
		/*then the left piece is empty*/
		gapH = -1;
	if (vh > ch2){
		/*then the right piece is empty*/
		gapH = -1;
		/*vh--;*/
	}
@
@= crkTwoRTreeCopy
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedTwoCopy@2_LE_@1(bo,*hgh, cl2, ch2,&vh, b);
        else
                CRKcrackUnorderedTwoCopy@2_RE_@1(bo,*hgh, cl2, ch2,&vh, b);

        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                /*vh--;*/
        }
@
@= CreateResult
createView:
	assert(0);
	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	else
		view = BATslice(b, vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);

	if (createIndex==1)
	{
		MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
		//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");
		createIndex=0;	
	}

@
@= RangeSelectBody

	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	int *t;
	int createIndex=0;
	pthread_rwlock_t *plock=0;
	oid vl=0, vh=0, posl, posh;
	/* vl and vh are the low and high index values to create the view with the result */
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	/* index values in the case we have to crack
		|cl1...........ch1|.....................|cl2.........ch2|
		if we have to crack only one piece, i.e., if our range falls
		in one piece only then we crack from cl to ch otherwise we use
		the other indices as it is shown */
	oid _vl=0;
	/*oid temp_vl=0,temp_vh=0;*/
	bit HBound, foundLow=0, foundHgh=0;
	bit LBound=FALSE;
	int gapL = 1;
	int gapH = 1;
	bit rippledDeletions = FALSE;
	struct Node *lowNode=NULL, *hghNode=NULL, *lowNodeNext=NULL, *temp;
	BUN idxFirst;
	int incr_pieces=0;
	struct timeval tv0, tv1;
	double wt=0, ct=0;
	bit copy=TRUE;	
	int countBatElements=0;
	int L1=0; /*Number of elements that can fit into L1 cache (size: 32KB)*/	
	int mod_bid=0;
	FILE *ofp;
	char *outputFilename1;
	FrequencyNode* FN;
	FrequencyNode *FrequencyStructA = getFrequencyStruct('A');

	gettimeofday(&tv0,0);
	
	outputFilename1 = getenv("HOLOUTPUT_PIECES");
	if (outputFilename1 == NULL){
  		fprintf(stderr, "Error: HOLOUTPUT_PIECES\n");
  		exit(1);
	}

	L1=32000/ATOMsize(TYPE_@1);

	ofp = fopen(outputFilename1,"a");
	if (ofp == NULL) {
  		fprintf(stderr, "Can't open output file!\n");
  		exit(1);
	}

	mod_bid=ABS(*bid)%LOCKS;

	MT_lock_set(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_set(&CRKIndexLock,"Cracker Index Lock");

	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;

	/*if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.crack", "illegal range");*/
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);
	/*fprintf(stderr,"*BID=%d\n",*bid);*/
	/* if this is the first time we selectholpl something from this bat,
		we have to create the crack index for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if (copy){
			if ((bo = BATdescriptor(*bid)) == NULL)
				throw(MAL, "crackers.crackRange", "Cannot access descriptor");
			b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
			if ( bo->htype == TYPE_void)
				b = BATmaterializeh(b);
			b->hsorted = FALSE;
			b->tsorted = FALSE;
			b->hdense = FALSE;
			b->tdense = FALSE;
			/*BATkey(b,TRUE);*/
			BATkey(BATmirror(b),FALSE);
			b->batRestricted= BAT_READ;
			BATmode(b,PERSISTENT);
			bo->batRestricted= BAT_READ;

			m = newCrackerIndex_@1(*bid,b->batCacheid);
			BBPincref(*bid, TRUE);

			if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
				throw(MAL, "crackers.crackRange", "Cannot access crack index");

			/* Since the index is empty we know we have to crack
			   anyway so crack in three pieces cl-ch */
			posl = BUNfirst(b);
			posh = BUNlast(b)-1;

			/*printf(" "LLFMT" \n ",posh-posl);*/
			@:crkThreeTree@5(@1,posl,posh,@5)@
			incr_pieces=incr_pieces+2;

			createIndex=1;			
			countBatElements=BATcount(b);

			gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
			MT_lock_set(&frequencylock, "getFrequencyStruct");
			gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
			CRKinitFrequencyStruct(0,*bid);
			FN=searchBAT(FrequencyStructA,*bid);					
			FN->f1 = FN->f1 + 1;
			FN->c = FN->c + incr_pieces;
			FN->weight = changeWeight(FN,countBatElements,L1);
			gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
			//PAPI_read_counters(counters, 2);
			//fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\t L2_DCA= \t %lld \t L2_DCM \t %lld\n",FN->bid,FN->c,wt,ct,MT_getpid(),counters[0],counters[1]);
			fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\n",FN->bid,FN->c,wt,ct,MT_getpid());
			fclose(ofp);
			MT_lock_unset(&frequencylock, "getFrequencyStruct");

			/*printFrequencyStruct(FrequencyStructA);*/
			BBPincref(b->batCacheid,TRUE);
			BBPunfix(bo->batCacheid);
			goto tempcreateView;
		}
		else{
			assert(0);
                        if ((bo = BATdescriptor(*bid)) == NULL)
                                throw(MAL, "crackers.crackRange", "Cannot access descriptor");

                        b=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
                        b->hsorted = FALSE;
                        b->tsorted = FALSE;
                        b->hdense = FALSE;
                        b->tdense = FALSE;
                        BATkey(BATmirror(b),FALSE);
                        b->batRestricted= BAT_READ;
                        BATmode(b,PERSISTENT);
                        BATsetcount(b,BATcount(bo));
                        bo->batRestricted= BAT_READ;

                        m = newCrackerIndex_@1(*bid,b->batCacheid);
			BBPincref(*bid, TRUE);

	
                        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                                throw(MAL, "crackers.crackRange", "Cannot access crack index");

                        /* Since the index is empty we know we have to crack
                           anyway so crack in three pieces cl-ch */
                        posl = BUNfirst(b);
                        posh = BUNlast(b)-1;

                        /*printf(" "LLFMT" \n ",posh-posl);*/
                        @:crkThreeTreeCopy(@1,posl,posh,@5)@

                        BBPincref(b->batCacheid,TRUE);
                        BBPunfix(bo->batCacheid);
                        goto tempcreateView;
                }
		
	}
	


		/* If an index exists for this bat (so it has been cracked before)
		we search the index to find where our range falls after this
		search if we have a match on the low range vl will hold the
		index value, otherwise it will be -1. The same for hgh and vh
		if there is no match for low then cl will hold the index that
		from there on we have to crack. The same from hgh and ch
		Note that in the case of the low range  we always have to increment
		by one since we want the values that are after this index
		(because of the way the crack index is created).
		Also after the search l and h should point to the low and hgh indices
		(in the crack index) found either as a match or to crack.
		This is used later on to determine which pieces we have to crack */

	/* Check if this bat was previously cracked but the map is not there anymore
		this may happen if we chose to forget the index because of updates, so now we
		have to create a new one and crack in three pieces anyway */
	if (CrackerIndex[m].reCreate == 1){
		reCreateMap_@1(m); assert(0);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access cracker BAT");
	
		posl = BUNfirst(b);
		posh = BUNlast(b)-1;

		@:crkThreeTree@5(@1,posl,posh,@5)@
		goto tempcreateView;
	}
	
	/* Take the index of the bat */
	

	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	idxFirst = BUNfirst(c);

	/* deal with pending deletions if any */

	if (CrackerIndex[m].mergeDeletions >= 0){
		str msg = selectMergeDeletionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, &rippledDeletions, m);
		assert(0);
		if (msg != NULL)
			throw(MAL, "crackers.crackRange", "%s", msg);
	}
	
	if (CrackerIndex[m].mergeDeletions == 2 && rippledDeletions == FALSE){
		assert(0);
		lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, NULL);
                if (lowNode == NULL){
                        lowNodeNext = NULL;
                        temp = CrackerIndex[m].Tree;
                        if (temp->deleted == FALSE)
                                lowNodeNext = temp;
                        while (temp->left != NULL){
                                temp = temp->left;
                                if (temp->deleted == FALSE)
                                        lowNodeNext = temp;
                        }
                } else
                        lowNodeNext = findNextPiece(lowNode);

		shiftHoles_@1(lowNode, lowNodeNext, b, c, idxFirst, hgh, inclusiveHgh, m);	
	}

	/* deal with pending insertions if any */
	if (CrackerIndex[m].mergeInsertions >= 0){
		str msg; assert(0);
		msg = selectMergeInsertionsPart_@1(bid, low, inclusiveLow, hgh, inclusiveHgh, m);
                if (msg != NULL)
                        throw(MAL, "crackers.crackRange", "%s", msg);
	}
		

	MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");

	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	
	retry:;

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);

	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;


	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0 && LBound==FALSE) cl1++;
	if (cl2 != 0) cl2++;

	/*printf("cl1 "OIDFMT" cl2 "OIDFMT" ", cl1,cl2  );*/
	
	/* find the hols if any in the pieces to crack so that cracking does not touch deleted buns */
        if (CrackerIndex[m].mergeDeletions == 2){
		oid holsLow = 0, holsHgh = 0; assert(0);
		/* if not done before while shifting hols find lowNode and lowNodeNext */
		if (rippledDeletions == TRUE){
			lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, NULL);
       	         	if (lowNode == NULL){
                        	lowNodeNext = NULL;
                   		temp = CrackerIndex[m].Tree;
                        	if (temp->deleted == FALSE)
                                	lowNodeNext = temp;
                        	while (temp->left != NULL){
                                	temp = temp->left;
                                	if (temp->deleted == FALSE)
                                	        lowNodeNext = temp;
                        	}
                	} else
                        	lowNodeNext = findNextPiece(lowNode);
		}

		hghNode = findNodeH_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, idxFirst, NULL);
		if (lowNodeNext != NULL)
			holsLow = lowNodeNext->hols;

		if (hghNode != NULL)
			holsHgh = hghNode->hols;

		/* so if there are hols the positions where we crack are appropriately decreased */
		ch1 -= holsLow;
		ch2 -= holsHgh;
	}

	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;

	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (foundLow == 0 || foundHgh == 0) {
		 if (foundLow == 0) {
			pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
			gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
			lowNode = findNodeL_@1(*low, TRUE, CrackerIndex[m].Tree, c, idxFirst, NULL);
			plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
			if (pthread_rwlock_trywrlock(plock)){
				pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
				gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
				pthread_rwlock_wrlock(plock);
				gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
				pthread_rwlock_unlock(plock);
				goto retry;	// some other thread might already crack on low, try to find it again
			}
			pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
			@:crkTwoLTree@5(@1,@5)@
			gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
			pthread_rwlock_wrlock(&CrackerIndex[m].columnRWLock);
			gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
			t = (int *) Tloc(b, BUNfirst(b));
			if (IndexSize < IndexStop) {
				if (vl > 0)
					_vl = vl - 1;
				else
					_vl = vl;
				if (gapL>0) 
				{
					addCrackerIndex_@1(m, low, *inclusiveLow, _vl, c);
					incr_pieces++;
				}
				if ((vl == 1) && (*t == *low) && (*inclusiveLow == TRUE))
					vl = vl - 1;
			}
			vh = ch2;
			pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
			pthread_rwlock_unlock(plock);
		}
		gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
		if (foundHgh == 0) {
			pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
			gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
			lowNode = findNodeL_@1(*hgh, TRUE, CrackerIndex[m].Tree, c, idxFirst, NULL);
			plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
			if (pthread_rwlock_trywrlock(plock)){
				pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
				gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
				pthread_rwlock_wrlock(plock);
				gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
				pthread_rwlock_unlock(plock);
				goto retry;	// some other thread might already crack on low, try to find it again
			}
			pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
			@:crkTwoRTree@5(@1,@5)@
			gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
			pthread_rwlock_wrlock(&CrackerIndex[m].columnRWLock);
			gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
			t = (int *) Tloc(b, BUNfirst(b));
			if (IndexSize < IndexStop)
				if (gapH>0) 
				{
					addCrackerIndex_@1(m, hgh, HBound, vh, c);
					incr_pieces++;					
				}
			vl = cl1;
			if ((vl == 0) && (*t < *low) && (*inclusiveLow == TRUE))
				vl = vl + 1;
			pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
			pthread_rwlock_unlock(plock);
		}
	} else {
		t = (int *) Tloc(b, BUNfirst(b));
		vl = cl1;
		if ((vl == 0) && (*t < *low) && (*inclusiveLow == TRUE))
			vl = vl + 1;
		vh = ch2;
	}

	/*@:CreateResult()@*/

	countBatElements=BATcount(b);
	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	MT_lock_set(&frequencylock, "getFrequencyStruct");
        gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
	FN=searchBAT(FrequencyStructA,*bid);
	FN->f1 = FN->f1 + 1;
	if (foundLow!=0 && foundHgh!=0)
		FN->f2 = FN->f2 + 1;
	FN->c = FN->c + incr_pieces;
	if(FN->weight > 0)
		FN->weight = changeWeight(FN,countBatElements,L1);
	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	//PAPI_read_counters(counters, 2);
	//fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\t L2_DCA \t %lld \t L2_DCM= \t %lld \n",FN->bid,FN->c,wt,ct,MT_getpid(),counters[0],counters[1]);
	fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\n",FN->bid,FN->c,wt,ct,MT_getpid());
	fclose(ofp);
	MT_lock_unset(&frequencylock, "getFrequencyStruct");
	
	tempcreateView:;

	posh = BUNlast(b)-1;
	idxFirst = BUNfirst(c);

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
	lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, NULL);
	if (lowNode == NULL){
		lowNodeNext = NULL;
		temp = CrackerIndex[m].Tree;
		if (temp->deleted == FALSE)
			lowNodeNext = temp;
		while (temp->left != NULL){
			temp = temp->left;
			if (temp->deleted == FALSE)
				lowNodeNext = temp;
		}
		vl = 0;
	} else {
		lowNodeNext = findNextPiece(lowNode);
		vl = lowNode->indexPosition;
	}
	hghNode = (lowNode == NULL)? lowNodeNext : findNextPiece(lowNode);
	vh = hghNode? hghNode->indexPosition : posh;
	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	if (!tail)
		view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
	else
		view = BATslice(b, vl, vh+1);
	
	*vid = view->batCacheid;
	BBPkeepref(*vid);
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	
	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;	

	if (createIndex==1)
	{
		MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
		//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");
		createIndex=0;	
	}

	return MAL_SUCCEED;
@
@= RangeSumBody
	int m;
	@1 *t0;
	BAT *b,*c;
	int *t;
	pthread_rwlock_t *plock=0;
	bit foundLow=0, foundHgh=0;
	bit LBound=FALSE;
	oid vl=0, vh=0, posh;
	BUN idxFirst;
	unsigned long long sum = 0;	
	/* vl and vh are the low and high index values to create the view with the result */
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	struct Node *lowNode=NULL, *hghNode=NULL, *lowNodeNext=NULL, *temp, *stopNode=NULL;
	(void) tail;

	m = existsCrackerIndex(*bid);
	
	if(m == -1)
		throw(MAL, "crackers.crackRange", "Index does not exist");

	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);

	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);


	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0 && LBound==FALSE) cl1++;
	if (cl2 != 0) cl2++;
	
	/* If one or both of the result view bounds were not found using the
	index then we have to crack */
	if (foundLow == 0 || foundHgh == 0) {
		throw(MAL, "crackers.crackRange", "Range is not found in index.");
	} else {
		t = (int *) Tloc(b, BUNfirst(b));
		vl = cl1;
		if ((vl == 0) && (*t < *low) && (*inclusiveLow == TRUE))
			vl = vl + 1;
		vh = ch2;
	}

	t0   = (@1 *)Tloc(b, BUNfirst(b));
	*vid = 0;

	posh = BUNlast(b)-1;
	idxFirst = BUNfirst(c);


	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
	lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, NULL);
	if (lowNode == NULL){
		lowNodeNext = NULL;
		temp = CrackerIndex[m].Tree;
		if (temp->deleted == FALSE)
			lowNodeNext = temp;
		while (temp->left != NULL){
			temp = temp->left;
			if (temp->deleted == FALSE)
				lowNodeNext = temp;
		}
		vl = 0;
	} else {
		lowNodeNext = findNextPiece(lowNode);
		vl = lowNode->indexPosition;
	}
	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	while (1){
		plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
		pthread_rwlock_rdlock(plock);
		hghNode = (lowNode == NULL)? lowNodeNext : findNextPiece(lowNode);
		vh = hghNode? hghNode->indexPosition : posh;
		while (vl<=vh){
			if (t0[vl] >= *low && t0[vl] < *hgh){
				sum += t0[vl];
				(*vid)++;
			}
			vl++;
		}
		pthread_rwlock_unlock(plock);
		if (!hghNode) break;
		if (hghNode == stopNode) break;
		lowNode = hghNode;
		vl = vh+1;
	}
	
	// verify the result
	if (!(sum == ((unsigned long long) *hgh - *low) * ((unsigned long long) *hgh + *low - 1)/ 2)){
		fprintf(stderr,"lo=%d, hi=%d, %llu, %llu\n",
			(int) *low, (int) *hgh, (unsigned long long) sum, 
			(unsigned long long) (((unsigned long long) *hgh - *low) * ((unsigned long long) *hgh + *low - 1)/ 2));
		assert(0);
	}
	
	BBPunfix(b->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
@
@= crackOperations

static oid
shiftHoles_@1(struct Node *lowNode, struct Node *lowNodeNext, BAT *b, BAT *c, BUN idxFirst, @1 *hgh, bit *inclusiveHgh, int position){
	oid holSize = 0, LposCr = 0, HposCr = 0, holPiece = 0, buns;
	oid *fh;
	@1 *ft;
	oid *hghPos = NULL;
	struct Node *hghNode, *stopNode;
	assert(0);
	fh = (oid*)Hloc(b, BUNfirst(b));
	ft = (@1 *)Tloc(b, BUNfirst(b));
	stopNode = findNodeH_@1(*hgh, *inclusiveHgh, CrackerIndex[position].Tree, c, idxFirst, NULL);

	while (1){
		if (lowNode == NULL)
			hghNode = lowNodeNext;
		 else
			hghNode = findNextPiece(lowNode);
		
		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
       	 	        hghPos = (oid*)Hloc(c, idxFirst + hghNode->position);
      		        LposCr = *(oid*)Hloc(c, idxFirst + lowNode->position) + holSize;
        	        HposCr = *hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
       	 	        hghPos = (oid*)Hloc(c, idxFirst + hghNode->position);
			LposCr = 0;
       	 	        HposCr = *hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			LposCr = *(oid*)Hloc(c, idxFirst + lowNode->position) + holSize;
       	                HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;
		buns = HposCr - LposCr;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns){
				memcpy(fh+(LposCr-(holSize-1)), fh+(LposCr+1), buns*sizeof(oid));
				memcpy(ft+(LposCr-(holSize-1)), ft+(LposCr+1), buns*sizeof(@1 ));
			}
			else{
				memcpy(fh+(LposCr-(holSize-1)), fh+(LposCr+1+(buns-holSize)), holSize*sizeof(oid));
				memcpy(ft+(LposCr-(holSize-1)), ft+(LposCr+1+(buns-holSize)), holSize*sizeof(@1 ));
			}
		}
		holSize += holPiece;
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			hghNode->hols = 0;
			lowNode = hghNode;
			*hghPos = *hghPos - holSize;
		} else
			break;
	}

	if (holSize > 0){
		if (hghNode == NULL){
			/*BUN crkLast = BUNlast(b) - holSize;
			b->batBuns->free = crkLast - b->batBuns->base;*/
	       		BATsetcount(b, BUNlast(b)-holSize);
		} else
	                hghNode->hols = holSize;
	}

	return holSize;
}


static str
selectMergeDeletionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, bit *rippledDeletions, int position){
	BAT *u;
	oid updates, updatesStart, updatesEnd;
	BUN l;
	@1 *lt, *updLast, *t0 ;

	if (CrackerIndex[position].did == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].did)) == NULL)
		return "Cannot access the deletions BAT";			

	if (CrackerIndex[position].mergeInsertions > 0){
                        BAT *insertions, *intersect;
                        if (CrackerIndex[position].iid < 0) goto findDeletes; 
                        if ((insertions = BATdescriptor(CrackerIndex[position].iid)) == NULL)
                                goto findDeletes;
                        if (BATcount(insertions)==0) {
                                BBPunfix(insertions->batCacheid);
                                goto findDeletes;
                        }

                        intersect = BATsintersect(insertions,u);

                        if (BATcount(intersect)>0){
                                insertions = BATdel(insertions,intersect,TRUE);
                                u = BATdel(u,intersect,TRUE);
                        }

                        BBPunfix(intersect->batCacheid);
                        BBPunfix(insertions->batCacheid);
        }

	findDeletes:;
	
	updates = BATcount(u);
	if (updates == 0){
		BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the deletions */
        }

	/* if necessary, sort in place the deletions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the deletions*/
	l  = SORTfndfirst(u,low);
	lt = (@1*)Tloc(u,l);
	t0 = (@1*)Tloc(u,BUNfirst(u));
	updLast = (@1*)Tloc(u, BUNlast(u));

        /* no qualifying values in the deletions */
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; 
	}

	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt ++;
	} 
			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */
	}

	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the deletions */ 	
	}

	updatesStart = (oid) (lt-t0);	
	
	/* binary search to find the position of the highest requested value in the deletions */
        l = SORTfndfirst(u, hgh);
	lt = (@1*)Tloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                         	lt ++;
			lt--;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt --;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt --;
	}

	if (lt == updLast) lt--;
	updatesEnd = (oid) (lt-t0);

	BBPunfix(u->batCacheid);
		
	if (CrackerIndex[position].mergeDeletions == 0){	
		/* merge completely */
		mergeDeletions_@1_oid(bid, &CrackerIndex[position].did, 0, updates-1);
		CrackerIndex[position].mergeDeletions = -1 ;
		CrackerIndex[position].did = -1;

	} else if (CrackerIndex[position].mergeDeletions == 1)
		/* merge only the requested values */			
		mergeDeletionsGradually_@1_oid(bid, &CrackerIndex[position].did, updatesStart, updatesEnd);
			
	else if (CrackerIndex[position].mergeDeletions == 2){
		/* merge only the requested values using the ripple strategy */
		mergeDeletionsGraduallyRipple_@1_oid(bid, &CrackerIndex[position].did, updatesStart, updatesEnd, low, *inclusiveLow, hgh, *inclusiveHgh);	
		*rippledDeletions = TRUE;
	}

	return NULL;
}


static str
selectMergeInsertionsPart_@1(int *bid, @1 *low, bit *inclusiveLow, @1 *hgh, bit *inclusiveHgh, int position){
	BAT *u,*b;
	oid updates, updatesStart, updatesEnd;
	BUN l;
	@1 *lt, *updLast, *t0;

	if (CrackerIndex[position].iid == -1) return NULL;
	if ((u = BATdescriptor(CrackerIndex[position].iid)) == NULL)
		return "Cannot access insertions BAT";			

	updates = BATcount(u);
	if (updates == 0){
        	BBPunfix(u->batCacheid);
                return NULL; /* no qualifying values in the insertions */
        }

	/* if necessary, sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	/* binary search to find the position of the lowest requested value in the insertions */
	l = SORTfndfirst(u,low);
	lt = (@1*)Tloc(u,l);
	t0 = (@1*)Tloc(u, BUNfirst(u));
	updLast = (@1*)Tloc(u, BUNlast(u));
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if (@2_EQ(lt,low,@3@1) && *inclusiveLow == FALSE){
		while (lt < updLast && @2_EQ(lt,low,@3@1))
			lt ++;
	} 			
	if (lt == updLast){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */
	}
	if ( @2_GT(lt,hgh,@3@1) || (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh==FALSE) ){
		BBPunfix(u->batCacheid);	
		return NULL; /* no qualifying values in the insertions */ 	
	}
	updatesStart = (oid) (lt-t0);	
	
	/* binary search to find the position of the highest requested value in the insertions */
        l  = SORTfndfirst(u, hgh);
	lt = (@1*)Tloc(u,l);
	if (lt < updLast){
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == TRUE){	
			while (lt < updLast && @2_EQ(lt,hgh,@3@1))
                            	lt ++;
			lt--;
		} else
		if (@2_EQ(lt,hgh,@3@1) && *inclusiveHgh == FALSE)
                        lt --;
		else
		if ( @2_GT(lt,hgh,@3@1) )
                        lt --;
	}

	if (lt == updLast) lt--;
	updatesEnd = (oid) (lt-t0);	
	if (CrackerIndex[position].mergeInsertions == 0){	
		/* merge completely */
		BBPunfix(u->batCacheid);

		mergeInsertionsB_@1_oid(bid, &CrackerIndex[position].iid, 0, updates-1);
		CrackerIndex[position].mergeInsertions = -1 ;
		CrackerIndex[position].iid = -1;

	} else if (CrackerIndex[position].mergeInsertions == 1){
		/* merge only the requested values */			
		BBPunfix(u->batCacheid);
		mergeInsertionsBGradually_@1_oid(bid, &CrackerIndex[position].iid, updatesStart, updatesEnd);
	}
	 else if (CrackerIndex[position].mergeInsertions == 2){
		/* merge only the requested values using the ripple strategy */
		if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access crack index");
		mergeInsertionsBRipple_@1_oid(b, u, updatesStart, updatesEnd, hgh, *inclusiveHgh, position);	
		BBPunfix(u->batCacheid);
		BBPunfix(b->batCacheid);
	}	
	return NULL;
}

/* This function takes a range and returns a view with the result. 
To do that, we first search the index to determine which parts of the result we already
know and which parts we have to crack. Then we crack, if necessary,
the appropriate pieces, update the index and return the result */
static str
CRKRangeTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail, int nthreads, int vector_elements){	
	@:RangeSelectBody(@1,@2,@3,@4,)@
}
static str
CRKRangeSumTree_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, bit tail){	
	@:RangeSumBody(@1,@2,@3,@4,)@
}

static str
CRKRangeLeftNilTree_@1(int *vid, int *bid, @1 *hgh, bit *inclusiveHgh, bit tail, int nthreads, int vector_elements){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	oid vl=0, vh=0;
	oid cl2=0, ch2=0;
	bit HBound,foundHgh=0;
	int gapH = 1;
	int createIndex=0;	
	struct Node *lowNode=NULL;
	pthread_rwlock_t *plock=0;
	BUN idxFirst = BUN_NONE;
	int incr_pieces=0;
	struct timeval tv0, tv1, tv0_copy, tv1_copy;
        double wt=0, ct=0;
	int L1=0;
	int mod_bid=0;
	int countBatElements=0;
	FrequencyNode* FN;
	FrequencyNode *FrequencyStructA = getFrequencyStruct('A');
	FILE *ofp, *ofp_copy;
	char *outputFilename1, *outputFilename2;
        //long long counters[2];
 	//int PAPI_events[] = {
        //      PAPI_L2_DCA,
        //      PAPI_L2_DCM};

        //PAPI_start_counters(PAPI_events, 2);

	gettimeofday(&tv0,0);
	
	outputFilename1 = getenv("HOLOUTPUT_PIECES");
	outputFilename2 = getenv("HOLISTIC_COPY_TIME");
	if (outputFilename1 == NULL){
  		fprintf(stderr, "Error: HOLOUTPUT_PIECES\n");
  		exit(1);
	}
	if (outputFilename2 == NULL){
  		fprintf(stderr, "Error: HOLISTIC_COPY_TIME\n");
  		exit(1);
	}

	ofp = fopen(outputFilename1,"a");

	if (ofp == NULL) {
  		fprintf(stderr, "Can't open output file!\n");
  		exit(1);
	}

	L1=32000/ATOMsize(TYPE_@1);
	
	mod_bid=ABS(*bid)%LOCKS;

        MT_lock_set(&CRKIndexLock[mod_bid],"Cracker Index Lock");
        //MT_lock_set(&CRKIndexLock,"Cracker Index Lock");
	gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;

	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we selectpl something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");

		ofp_copy = fopen(outputFilename2,"a");
	
		if (ofp_copy == NULL) {
  			fprintf(stderr, "Can't open output file!\n");
  			exit(1);
		}

		gettimeofday(&tv0_copy, 0);
                b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
                if ( bo->htype == TYPE_void)
                        b = BATmaterializeh(b);
		//b=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
		gettimeofday(&tv1_copy, 0);
		fprintf(ofp_copy,"%d\n",(int)dt(tv0_copy,tv1_copy)*1000000);

		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		//CRKparallelcopy_LE_@1(b, bo, (BUN) 0, BATcount(bo)-1, nthreads);
		//BATkey(BATmirror(b),FALSE);
                //BATsetcount(b,BATcount(bo));

		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl2 = BUNfirst(b);
		ch2 = BUNlast(b)-(oid)1;
		@:crkTwoRTree(@1)@
		if (gapH>0)
		{
			addCrackerIndex_@1(m,hgh,HBound,vh,c);
			incr_pieces++;
		}
		vl = BUNfirst(b);
		
		createIndex=1;		
	 	countBatElements=BATcount(b);
	
		gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
		MT_lock_set(&frequencylock, "getFrequencyStruct");
		gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
		CRKinitFrequencyStruct(0,*bid);
		FN=searchBAT(FrequencyStructA,*bid);					
		FN->f1 = FN->f1 + 1;
		FN->c = FN->c + incr_pieces;
		FN->weight = changeWeight(FN,countBatElements,L1);
		gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
		//PAPI_read_counters(counters, 2);
		//fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\t L2_DCA= \t %lld \t L2_DCM \t %lld\n",FN->bid,FN->c,wt,ct,MT_getpid(),counters[0],counters[1]);
		fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\n",FN->bid,FN->c,wt,ct,MT_getpid());
		fclose(ofp);
		fclose(ofp_copy);
		MT_lock_unset(&frequencylock, "getFrequencyStruct");

		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto tempcreateViewL;
	}
	
	if (CrackerIndex[m].cid == -1){
		assert(0);
		reCreateMap_@1(m);
	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl2 = BUNfirst(b);
		ch2 = BUNlast(b)-(oid)1;
		@:crkTwoRTree(@1)@
		if (gapH>0) addCrackerIndex_@1(m,hgh,HBound,vh,c);
		vl = BUNfirst(b);

		goto tempcreateViewL;
	}

	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	idxFirst = BUNfirst(c);

	MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");

        gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;

	vl = BUNfirst(b);

	retryL:

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);

        gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;

	/* find out where in the index the high falls */
	foundHgh = GetHgh_@1(*hgh, HBound, CrackerIndex[m].Tree, c, BUNfirst(c), &cl2, &ch2, 0, BUNlast(b)-(oid)1);

	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl2 != 0) cl2++;

       gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;

	if (foundHgh == 0){
		pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
                gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
                lowNode = findNodeL_@1(*hgh, TRUE, CrackerIndex[m].Tree, c, idxFirst, NULL);
                plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
                if (pthread_rwlock_trywrlock(plock)){
                	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                        gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
                        pthread_rwlock_wrlock(plock);
                        gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
                        pthread_rwlock_unlock(plock);
                        goto retryL;     // some other thread might already crack on low, try to find it again
                }
                pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
		@:crkTwoRTree(@1)@
                gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
		pthread_rwlock_wrlock(&CrackerIndex[m].columnRWLock);
                gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
		if (IndexSize <IndexStop)
		{
			if(gapH>0)
			{
				addCrackerIndex_@1(m,hgh,HBound,vh,c);
				incr_pieces++;
			}
		}
		pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                pthread_rwlock_unlock(plock);
	} 	
	else
		vh = ch2;

        gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	countBatElements=BATcount(b);
	MT_lock_set(&frequencylock, "getFrequencyStruct");
        gettimeofday(&tv1,0); wt+=dt(tv0,tv1); tv0=tv1;
	FN=searchBAT(FrequencyStructA,*bid);
	FN->f1 = FN->f1 + 1;
	if (foundHgh != 0)
		FN->f2 = FN->f2 + 1;
	FN->c = FN->c + incr_pieces;
	if(FN->weight > 0)
		FN->weight = changeWeight(FN,countBatElements,L1);
	gettimeofday(&tv1,0); ct+=dt(tv0,tv1); tv0=tv1;
	//PAPI_read_counters(counters, 2);
	//fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\t L2_DCA \t %lld \t L2_DCM= \t %lld \n",FN->bid,FN->c,wt,ct,MT_getpid(),counters[0],counters[1]);
	fprintf(ofp,"User_Query \t 0 \t Bat_id= \t %d \t Pieces= \t %d \t Wait_time\t %9.6lf \t Selection_time\t %9.6lf \t Thread_id= \t" SZFMT "\n",FN->bid,FN->c,wt,ct,MT_getpid());
	fclose(ofp);
	MT_lock_unset(&frequencylock, "getFrequencyStruct");



	tempcreateViewL:

	if (!tail)
                view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
        else
                view = BATslice(b, vl, vh+1);

        *vid = view->batCacheid;
        BBPkeepref(*vid);
        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);

        if (createIndex==1)
        {
                MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
                //MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");
                createIndex=0;
        }

	return MAL_SUCCEED;
}

static str
CRKRangeRightNilTree_@1(int *vid, int *bid, @1 *low, bit *inclusiveLow, bit tail, int nthreads, int vector_elements){
	BAT *b,*c,*bo;
	BAT *view;
	int  m;
	oid vl=0, vh=0;
	oid cl1=0, ch1=0;
	bit foundLow=0;
	int gapL = 1;
	bit LBound=FALSE;
	int createIndex=0;
        struct Node *lowNode=NULL;
	pthread_rwlock_t *plock=0;
        BUN idxFirst = BUN_NONE;
	int incr_pieces=0;
	int L1=0;
	int mod_bid=0;
	int countBatElements;
	FrequencyNode* FN;
	FrequencyNode *FrequencyStructA = getFrequencyStruct('A');
	FILE *ofp;
	char *outputFilename1;


	//gettimeofday(&tv0,0);
	
	outputFilename1 = getenv("HOLOUTPUT_PIECES");
	if (outputFilename1 == NULL){
  		fprintf(stderr, "Error: HOLOUTPUT_PIECES\n");
  		exit(1);
	}

	ofp = fopen(outputFilename1,"a");
	if (ofp == NULL) {
  		fprintf(stderr, "Can't open output file!\n");
  		exit(1);
	}

	L1=32000/ATOMsize(TYPE_@1);

	mod_bid=ABS(*bid)%LOCKS;

        MT_lock_set(&CRKIndexLock[mod_bid],"Cracker Index Lock");
        //MT_lock_set(&CRKIndexLock,"Cracker Index Lock");

	m = existsCrackerIndex(*bid);

	/* if this is the first time we selectpl something from this bat,
		we have to create the crack indx for it and
	   if necessary materialize the head of the bat */
	if (m == -1){
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access descriptor");
		b = BATcopy(bo, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		b->batRestricted= BAT_READ;
		BATmode(b,PERSISTENT);
		bo->batRestricted= BAT_READ;

		BBPincref(*bid, TRUE);
		m = newCrackerIndex_@1(*bid,b->batCacheid);

		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		cl1 = BUNfirst(b);
		ch1 = BUNlast(b)-(oid)1;
		@:crkTwoLTree(@1)@
		 if (gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNlast(b)-(oid)1;
		
		createIndex=1;
		countBatElements=BATcount(b);

		MT_lock_set(&frequencylock, "getFrequencyStruct");
		CRKinitFrequencyStruct(0,*bid);
		FN=searchBAT(FrequencyStructA,*bid);					
		FN->f1 = FN->f1 + 1;
		FN->c = FN->c + 1;
		fprintf(ofp,"%d\t%d\n",FN->bid,FN->c);
		fclose(ofp);
		FN->weight = changeWeight(FN,countBatElements,L1);
		MT_lock_unset(&frequencylock, "getFrequencyStruct");

		BBPincref(b->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		goto tempcreateViewR;
	}
	
	if (CrackerIndex[m].cid == -1){
		reCreateMap_@1(m);
		assert(0);	
		/* Take the index of the bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");

		/* Take the copy of the bat for which we maintain the index */
		if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
			throw(MAL, "crackers.crackRange", "Cannot access crack index");
	
		cl1 = BUNfirst(b);
		ch1 = BUNlast(b)-(oid)1;
		@:crkTwoLTree(@1)@
		if(gapL>0) addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
		vh = BUNlast(b)-(oid)1;

		goto tempcreateViewR;
	}


	/* Take the index of the bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	/* Take the copy of the bat for which we maintain the index */
	if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.crackRange", "Cannot access crack index");

	idxFirst = BUNfirst(c);

	MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
	//MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");

	vh = BUNlast(b)-(oid)1;

	retryR:

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);

	FN=searchBAT(FrequencyStructA,*bid);
	
	/* find out where in the index the low falls */
	foundLow = GetLow_@1(*low,*inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &cl1, &ch1, 0, BUNlast(b)-(oid)1,&LBound);
	
	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	/*need to increase one position for the low bound only since we always store the previous position in the index*/
	if (cl1 != 0) cl1++;

	if (foundLow == 0){
		pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
                lowNode = findNodeL_@1(*low, TRUE, CrackerIndex[m].Tree, c, idxFirst, NULL);
                plock = (lowNode == NULL)? &CRKFirstPieceRWLock : &lowNode->pieceLock;
                if (pthread_rwlock_trywrlock(plock)){
                	pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                	pthread_rwlock_wrlock(plock);
                        pthread_rwlock_unlock(plock);
                        goto retryR;     // some other thread might already crack on low, try to find it again
                }
                pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
		@:crkTwoLTree(@1)@
		pthread_rwlock_wrlock(&CrackerIndex[m].columnRWLock);
		if (IndexSize <IndexStop)
		{
			if(gapL>0)
			{
				addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
				incr_pieces++;
			}
		}
		pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);
                pthread_rwlock_unlock(plock);
	} 	
	else
		vl = cl1;


	countBatElements=BATcount(b);
	MT_lock_set(&frequencylock, "getFrequencyStruct");
	FN=searchBAT(FrequencyStructA,*bid);
	FN->f1 = FN->f1 + 1;
	if (foundLow != 0)
		FN->f2 = FN->f2 + 1;
	FN->c = FN->c + incr_pieces;
	fprintf(ofp,"%d\t%d\n",FN->bid,FN->c);
	fclose(ofp);
	if(FN->weight > 0)
		FN->weight = changeWeight(FN,countBatElements,L1);
	MT_lock_unset(&frequencylock, "getFrequencyStruct");

	
	tempcreateViewR:

	pthread_rwlock_rdlock(&CrackerIndex[m].columnRWLock);
        lowNode = findNodeL_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, idxFirst, NULL);
        if (lowNode == NULL){
                vl = 0;
        } else {
                vl = lowNode->indexPosition;
        }
        pthread_rwlock_unlock(&CrackerIndex[m].columnRWLock);

	if (!tail)
                view = BATslice(VIEWhead_(b, BAT_READ), vl, vh+1);
        else
                view = BATslice(b, vl, vh+1);

        *vid = view->batCacheid;
        BBPkeepref(*vid);
        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);

        if (createIndex==1)
        {
                MT_lock_unset(&CRKIndexLock[mod_bid],"Cracker Index Lock");
                //MT_lock_unset(&CRKIndexLock,"Cracker Index Lock");
                createIndex=0;
        }

	return MAL_SUCCEED;
}
@
